HTTP 학습을 기록하기 위한 저장소 입니다.
---------------
### 인터넷 네트워크
- TCP/IP 4계층 흐름
  - 내가 "Hello" 메시지를 http 패킷으로 만들면, TCP 패킷으로 감싸고, IP 패킷으로 감싸고 이게 랜선으로 나가는거야.
- IP 프로토콜
  - 출발지IP, 도착지IP, 데이터정보가 담겨있어
  - 비연결성, 비신뢰성, 데이터를 나눠 보낼때 순서도 보장 안되고, 프로그램 구분 안되는 한계가 있어
- TCP 프로토콜
  - 3 way handshaking으로 클라이언트와 서버가 연결된 것을 신뢰할 수 있어.
  - 순서도 알맞게 보장해주고.
  - port 값도 들어있어서 프로그램 구분도 돼.
  - 거의 99% 이상 TCP로 보냄.
- UDP 프로토콜
  - TCP와 같은 계층에 있어.
  - 거의 IP 프로토콜과 같은데, 여기에 port값만 추가되어있음.
  - 영상같은거 보낼때 UDP 쓴다 했는데, 요즘에는 영상도 TCP로 보냄. 
  - web 3.0 되면서 더 최적화 될 수 있는 가능성이 열려있긴함.
- Port : 같은 IP 내에서 프로세스를 구분하기 위한 값. IP가 아파트라면 Port는 몇동 몇호.
- DNS : Domain Name System. IP 주소는 변하기 쉽고 기억하기 어려우니 도메인명에 따른 IP주소를 저장하고 있는 서버가 있고 이를 DNS 서버라 함. 일종의 전화번호부

### URI와 웹 브라우저 요청 흐름
- URI vs URL
  - URL : 리소스 위치. 주로 웹사이트 들어갈때 주소창에 입력하는게 URL 이야.
  - URI : URL의 상위 개념으로 URL 뿐만 아니라 URN 이라든가 뭐 이것저것 다 가지고 있는데, 잘 사용하지 않고 URL만 사용.
  - 따라서 URL과 URI가 거의 동일한 개념으로 사용
- URL 분석 https://www.google.com/search?q=hello&hl=ko
  - 프로토콜,호스트주소,경로,쿼리 로 구성되어있음. 중간에 포트나, 사용자정보, fragment도 넘길 수 있는데 일반적으로 생략
  - https = http + secure
  - 경로 : 서버에서 리소스가 있는 곳을 계층적으로 찾아들어가서 나타내는곳
  - 쿼리 : ? 다음에 나오는데 키 벨류 형태로 보내고 &로 여러 매개변수를 전달할 수 있음. 쿼리 스트링, 쿼리 파라미터라고 부르기도 함. 서버에 문자열로 보내짐  

### HTTP 기본
- HTTP : 모든 것이 http. html, text, 영상, 그림 모든 걸 다 http로 전송함. 물론 그 기반에는 tcp, udp가 있고.
- Stateful vs Stateless
  - Stateful : 상태유지. 클라이언트쪽에서 보내온 정보를 계속 가지고 있어야 돼. 때문에 클라이언트와 연결된 서버를 바꾸기가 어려워
  - Stateless : 무상태. 클라이언트쪽에서 보내온 정보를 유지하고 있지 않음. 따라서 클라이언트쪽에서 요청할떄마다 데이터를 길게 보내줘야돼. 그러나 수평확장. 스케일아웃하기에 참 좋아. 즉 상황에 따라 서버들을 대거 투입할 수 있지. 더 대응이 유연하지.
  - 일반적으로 무상태로 설계를 대부분 하되, 로그인 정보를 유지해야 되는 상황 같은 경우에는 브라우저쿠키와 서버세션을 이용해서 상태유지로 설계함. 상태유지는 최소한으로.
- HTTP는 기본이 비연결성. 
  - 서버랑 계속 연결된 상태라면 서버의 자원 소비가 크겠지. 그렇고 뭐 할때마다 매번 3way 해야되면 성능이 떨어질테고. 
  - 초기에는 연결->html 보내고->종료, 연결-> 이미지 보내고 -> 종료.. 이래왔는데 지속연결이라는 개념으로 최적화 해서 연결 -> html보내고, 이미지 보내고 -> 종료. 이런식으로 진행.
- HTTP 메시지
  - 생각보다 단순해. 요청메시지와 응답 메시지의 시작라인은 내용이 좀 다른데, 둘다 시작라인, 헤더, 공백한줄, 바디. 구조는 똑같아
  - 시작라인은 요청메시지는 http 메소드랑 경로 들어있고, 응답메시지는 상태코드 200, 400 이런거 들어있음
### HTTP 메서드
- URI 설계
  - URI는 리소스만 식별. 리소스와 행위를 분리해야돼
  - 회원 조회, 회원 등록, 회원 삭제. 리소스는 회원, 행위는 조회/등록/삭제. 이걸 다 다른 URI로 두는게 아니라
  - /members/{id} 이거 하나로 잡고 행위는 http 메소드로 구분 하는거야.
- 메소드
  - GET: 조회
  - POST: 새로운 리소스 생성, 변경 뿐만 아니라, 리소스를 전달 받아서 프로세스 처리 해야되는 경우, get 이외의 경우에 대부분 post로 넘김.
  - PUT : 덮어씌움. 없다면 생성. 때문에 POST와 다르게 URI를 파일 위치까지 명시해줌. members/100
  - PATCH : 부분 변경. PUT은 전달하지 않은 필드들을 null로 덮어버리지만, PATCH는 다른 필드값을 갖는 애만 골라서 변경해줌. 다만 서버에 따라 지원 안하는 경우도 있는데, 그럴때는 그냥 POST 이용
  - DELETE : 삭제
- 메소드의 속성
  - 안전 : 리소스의 변경이 일어나지 않는 get만 안전
  - 멱등 : 한번 호출하든 100번 호출하든 결과가 동일한가? get, put, delete, patch 다 동일하지. 멱등해. post는 계속 새로운 데이터 생성되기에 동일하지 않고.
  - 캐시 가능 : 응답결과 리소스를 캐시로 저장해도 되는가? get, post, put, head 다 되는데, 메시지에 바디가 있는 경우 캐시 키를 구현하기가 까다로워서 보통 get과 head 정도만 캐시 사용. 

### HTTP 메서드 활용
- 메시지를 전달하는 2가지 방식
  - 쿼리 파라미터 
    - URI에 /search?q=hello&hl=ko 로 전달. GET
  - 메시지 바디
    - 쿼리 파라미터에 두는게 아니라 http 바디에다가 전달 메시지를 쿼리 파라미터의 형태로 담아서 전달. POST, PUT, PATCH
- 데이터를 전송하는 4가지 상황
  - 정적 컨텐츠 조회 : 그냥 GET으로 조회
  - 동적 컨텐츠 조회 : 그냥 GET으로 쿼리 파라미터 넣어서 조회
  - HTTP Form 데이터 전송 : HTML Form 데이터 배웠잖아. submit 하면, get일때는 해당 내용들이 쿼리파라미터로 전송되고, post 같은경우에는 메시지 바디에 담아서 전송
  - HTTP API 데이터 전송 : 서버끼리, 앱 클라이언트, 웹 클라이언트 중 react나 vue 같은거랑 통신할때. 컨텐츠타입은 JSON.
- 신규 회원 등록 같은건 POST, 파일 관리 시스템은 PUT
  - post는 리소스의 uri을 클라이언트쪽에서 지정해서 던지는게 아니라, 컬렉션 경로만 잡아주는데, 서버쪽에서 id 생성해서 uri을 만들고 클라이언트쪽으로 응답함
  - 그러나 파일 관리 시스템 처럼, 새로운 파일을 등록한다 치면, 클라이언트쪽에 리소스의 uri를 정확히 지정해줘야겠지. 예를 들면 members/star.jpg 처럼. 때문에 post가 아니라 put으로 보내는거야
  - post로 등록하는것을 컬렉션. put으로 등록하는것을 스토어라 하는데 거~의 대부분은 post로 진행함.
- 순수 http form에는 get과 post만 사용할 수 있어. 때문에 edit, delete도 다 post로 진행시켜야 하고, 때문에 리소스가 아닌 행위로 명명한 **컨트롤 uri**라는 개념이 들어옴
  - 컨트롤 uri의 예 : /members/{id}/delete
  - 여기서 순수 http form 이라는 개념이 와닿지 않긴한데, 왜냐면 게시판에 글쓰는거 구현하거나 수정할때 patch, delete 다 사용해서 구현했는데? 일단 좀 보자.


### HTTP 상태코드
- 2xx : 성공. 200 요청성공, 201 created 성공
- 3xx : 리다이렉션
  - 리다이렉트 : 클라이언트가 요청한 uri가 아니라 바뀐 uri를 응답으로 보내서 클라이언트가 자동으로 바뀐 uri 쪽으로 요청을 보낼 수 있게 해줌
  - 307 : 기존에 클라이언트가 post로 요청한 http 메소드와 메시지를 리다이렉트할때 유지함.
  - 302 : 보통 유지 안하고 get으로 변경시켜버림. 얘를 제일 많이 사용함.
  - 303 : 무조건적으로 get으로 변경시켜버림.
  - 304 : 캐시를 리다이렉트 한다고 하는데 이건 캐시 파트 가서 다시 정리해야할듯.
  - PRG : Post Redirect Get. 클라이언트가 post 요청했는데, get으로 리다이렉트 시키는거. 주문 요청할때 post 이후 주문 완료 페이지를 get 하게 리다이렉트 시켜야 새로고침시 중복 주문 안됨.
- 4xx : 클라이언트 오류
- 5xx : 서버 오류

### HTTP 헤더1 - 일반 헤더

### HTTP 헤더2 - 캐시와 조건부 요청




  
  
  
  
  
  
  
  
